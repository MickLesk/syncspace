<script>
  import { onMount, onDestroy } from "svelte";
  import { files, currentPath } from "../../stores/ui";
  import { success, error as errorToast } from "../../stores/toast";
  import { favorites } from "../../stores/favorites";
  import PageWrapper from "../../components/PageWrapper.svelte";
  import Breadcrumbs from "../../components/Breadcrumbs.svelte";
  import SearchFilters from "../../components/search/SearchFilters.svelte";
  import BatchOperationsToolbar from "../../components/ui/BatchOperationsToolbar.svelte";
  import UploadProgress from "../../components/files/UploadProgress.svelte";
  import api from "../../lib/api";
  import { websocketManager } from "@stores/websocket.js";

  let loading = true;
  let uploadInput;
  let searchQuery = "";
  let viewMode = "grid";
  let sortBy = "name";
  let sortOrder = "asc";
  let selectedFiles = [];
  let uploadProgress = [];
  let showUploadPanel = false;
  let dragOver = false;

  let searchFilters = {
    type: "all",
    dateFrom: null,
    dateTo: null,
    minSize: null,
    maxSize: null,
  };

  let unsubscribeFileEvent;

  onDestroy(() => {
    if (unsubscribeFileEvent) unsubscribeFileEvent();
    window.removeEventListener("keydown", handleKeyDown);
  });

  function handleKeyDown(e) {
    // Ctrl+A: Select All
    if (e.ctrlKey && e.key === "a") {
      e.preventDefault();
      selectAll();
    }

    // Delete: Delete selected files
    if (e.key === "Delete" && selectedFiles.length > 0) {
      e.preventDefault();
      handleBatchDelete();
    }

    // Escape: Clear selection
    if (e.key === "Escape" && selectedFiles.length > 0) {
      e.preventDefault();
      clearSelection();
    }

    // Ctrl+U: Upload
    if (e.ctrlKey && e.key === "u") {
      e.preventDefault();
      uploadInput?.click();
    }

    // Ctrl+F: Focus search
    if (e.ctrlKey && e.key === "f") {
      e.preventDefault();
      const searchInput = document.querySelector('input[type="text"]');
      if (searchInput instanceof HTMLInputElement) searchInput.focus();
    }
  }

  onMount(async () => {
    await loadFiles();
    unsubscribeFileEvent = websocketManager.on("file_change", (event) => {
      console.log("File event:", event);
      loadFiles();
    });
    window.addEventListener("keydown", handleKeyDown);
  });

  async function loadFiles(path = null) {
    loading = true;
    try {
      const targetPath = path || $currentPath;
      const response = await api.files.list(targetPath);
      const fileList = Array.isArray(response) ? response : response.data || [];
      files.set(fileList);
      if (path) currentPath.set(path);
    } catch (err) {
      errorToast("Failed to load files");
      console.error(err);
    } finally {
      loading = false;
    }
  }

  async function handleUpload(fileList = null) {
    const filesToUpload = fileList || uploadInput?.files;
    if (!filesToUpload?.length) return;

    showUploadPanel = true;

    for (let file of filesToUpload) {
      const uploadId = Date.now() + Math.random();
      uploadProgress = [
        ...uploadProgress,
        {
          id: uploadId,
          name: file.name,
          progress: 0,
          status: "uploading",
        },
      ];

      try {
        await api.files.uploadWithProgress($currentPath, file, (percent) => {
          uploadProgress = uploadProgress.map((up) =>
            up.id === uploadId ? { ...up, progress: percent } : up
          );
        });

        uploadProgress = uploadProgress.map((up) =>
          up.id === uploadId ? { ...up, status: "complete", progress: 100 } : up
        );
        success(`Uploaded: ${file.name}`);
      } catch (err) {
        uploadProgress = uploadProgress.map((up) =>
          up.id === uploadId ? { ...up, status: "error" } : up
        );
        errorToast(`Failed to upload: ${file.name}`);
      }
    }

    if (uploadInput) uploadInput.value = "";
    await loadFiles();

    setTimeout(() => {
      uploadProgress = uploadProgress.filter((up) => up.status === "uploading");
      if (uploadProgress.length === 0) showUploadPanel = false;
    }, 3000);
  }

  function handleDrop(e) {
    dragOver = false;
    const files = e.dataTransfer?.files;
    if (files) handleUpload(files);
  }

  function handleDragOver(e) {
    dragOver = true;
  }

  function handleDragLeave() {
    dragOver = false;
  }

  function toggleSelectFile(file) {
    const index = selectedFiles.findIndex((f) => f.name === file.name);
    if (index === -1) {
      selectedFiles = [...selectedFiles, file];
    } else {
      selectedFiles = selectedFiles.filter((_, i) => i !== index);
    }
  }

  function selectAll() {
    selectedFiles = [...$files];
  }

  function clearSelection() {
    selectedFiles = [];
  }

  async function handleBatchDelete() {
    if (!confirm(`Delete ${selectedFiles.length} files?`)) return;
    for (let file of selectedFiles) {
      try {
        await api.files.delete($currentPath + file.name);
      } catch (err) {
        errorToast(`Failed to delete: ${file.name}`);
      }
    }
    selectedFiles = [];
    await loadFiles();
  }

  async function handleBatchCopy(destination) {
    for (let file of selectedFiles) {
      try {
        await api.files.copy($currentPath + file.name, destination);
      } catch (err) {
        errorToast(`Failed to copy: ${file.name}`);
      }
    }
    selectedFiles = [];
    await loadFiles();
  }

  async function handleBatchMove(destination) {
    for (let file of selectedFiles) {
      try {
        await api.files.move($currentPath + file.name, destination);
      } catch (err) {
        errorToast(`Failed to move: ${file.name}`);
      }
    }
    selectedFiles = [];
    await loadFiles();
  }

  function applySearchFilters(fileList) {
    let filtered = fileList;

    if (searchQuery) {
      filtered = filtered.filter((f) =>
        f.name.toLowerCase().includes(searchQuery.toLowerCase())
      );
    }

    if (searchFilters.type !== "all") {
      filtered = filtered.filter((f) => {
        if (searchFilters.type === "folder") return f.is_directory;
        if (searchFilters.type === "file") return !f.is_directory;
        return true;
      });
    }

    if (searchFilters.minSize) {
      filtered = filtered.filter((f) => f.size_bytes >= searchFilters.minSize);
    }

    if (searchFilters.maxSize) {
      filtered = filtered.filter((f) => f.size_bytes <= searchFilters.maxSize);
    }

    return filtered;
  }

  function sortFiles(fileList) {
    return fileList.sort((a, b) => {
      let comparison = 0;

      if (sortBy === "name") {
        comparison = a.name.localeCompare(b.name);
      } else if (sortBy === "size") {
        comparison = (a.size_bytes || 0) - (b.size_bytes || 0);
      } else if (sortBy === "modified") {
        comparison =
          new Date(a.modified_at).getTime() - new Date(b.modified_at).getTime();
      }

      return sortOrder === "asc" ? comparison : -comparison;
    });
  }

  $: filteredFiles = applySearchFilters($files);
  $: sortedFiles = sortFiles(filteredFiles);
  $: displayFiles = sortedFiles;
</script>

<PageWrapper>
  <div class="p-6">
    <!-- Header -->
    <div
      class="flex flex-col md:flex-row items-start md:items-center justify-between mb-4 gap-4"
    >
      <Breadcrumbs
        path={$currentPath}
        on:navigate={(e) => loadFiles(e.detail)}
      />

      <div class="flex flex-wrap gap-2 w-full md:w-auto">
        <input
          type="text"
          bind:value={searchQuery}
          placeholder="Search files..."
          class="px-3 py-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 placeholder-gray-500 dark:placeholder-gray-400 flex-1 md:flex-initial"
        />
        <button
          on:click={() => uploadInput?.click()}
          class="px-4 py-2 bg-blue-600 hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600 text-white rounded transition-colors"
        >
          📤 Upload
        </button>
        <button
          on:click={() => (viewMode = viewMode === "grid" ? "list" : "grid")}
          class="px-4 py-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
        >
          {viewMode === "grid" ? "☰ List" : "⊞ Grid"}
        </button>
      </div>
    </div>

    <input
      bind:this={uploadInput}
      type="file"
      multiple
      class="hidden"
      on:change={() => handleUpload()}
    />

    <!-- Search Filters -->
    <SearchFilters
      onFilterChange={(newFilters) => {
        searchFilters = { ...searchFilters, ...newFilters };
      }}
    />

    <!-- Batch Operations Toolbar -->
    {#if selectedFiles.length > 0}
      <div
        class="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-700 rounded-lg p-4 mb-4 flex flex-col sm:flex-row items-start sm:items-center justify-between gap-3"
      >
        <span class="font-medium text-gray-900 dark:text-gray-100">
          ✓ {selectedFiles.length} file{selectedFiles.length > 1 ? "s" : ""} selected
        </span>
        <div class="flex gap-2 flex-wrap">
          <button
            on:click={handleBatchDelete}
            class="px-3 py-1 bg-red-600 hover:bg-red-700 dark:bg-red-500 dark:hover:bg-red-600 text-white rounded transition-colors"
          >
            🗑️ Delete
          </button>
          <button
            on:click={clearSelection}
            class="px-3 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
          >
            ✕ Clear
          </button>
        </div>
      </div>
    {/if}

    <!-- Upload Progress Panel -->
    {#if showUploadPanel}
      <UploadProgress uploads={uploadProgress} />
    {/if}

    <!-- File List with Drag & Drop -->
    <div
      role="region"
      aria-label="File drop zone"
      class="relative mt-4"
      class:border-4={dragOver}
      class:border-blue-500={dragOver}
      class:border-dashed={dragOver}
      on:drop|preventDefault={handleDrop}
      on:dragover|preventDefault={handleDragOver}
      on:dragleave={handleDragLeave}
    >
      {#if dragOver}
        <div
          class="absolute inset-0 bg-blue-50 dark:bg-blue-900/30 bg-opacity-90 flex items-center justify-center z-10 pointer-events-none rounded-lg"
        >
          <p class="text-2xl text-blue-600 dark:text-blue-400 font-bold">
            📤 Drop files here
          </p>
        </div>
      {/if}

      {#if loading}
        <p class="text-center py-8 text-gray-600 dark:text-gray-400">
          ⏳ Loading...
        </p>
      {:else if displayFiles.length === 0}
        <p class="text-center py-8 text-gray-500 dark:text-gray-400">
          📂 No files found
        </p>
      {:else}
        <div
          class={viewMode === "grid"
            ? "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4"
            : "space-y-2"}
        >
          {#each displayFiles as file}
            <button
              type="button"
              class="p-4 bg-white dark:bg-gray-800 rounded shadow hover:shadow-lg dark:shadow-gray-900/50 text-left w-full transition-all border border-transparent hover:border-blue-300 dark:hover:border-blue-600"
              class:ring-2={selectedFiles.find((f) => f.name === file.name)}
              class:ring-blue-500={selectedFiles.find(
                (f) => f.name === file.name
              )}
              class:dark:ring-blue-400={selectedFiles.find(
                (f) => f.name === file.name
              )}
              on:click={(e) => {
                if (e.shiftKey || e.ctrlKey) {
                  toggleSelectFile(file);
                } else if (file.is_directory) {
                  loadFiles($currentPath + file.name + "/");
                }
              }}
            >
              <div class="flex items-center gap-3">
                <span class="text-3xl flex-shrink-0"
                  >{file.is_directory ? "📁" : "📄"}</span
                >
                <div class="flex-1 min-w-0">
                  <p
                    class="font-medium truncate text-gray-900 dark:text-gray-100"
                  >
                    {file.name}
                  </p>
                  {#if !file.is_directory}
                    <p class="text-sm text-gray-500 dark:text-gray-400">
                      {(file.size_bytes / 1024).toFixed(1)} KB
                    </p>
                  {:else}
                    <p class="text-sm text-gray-500 dark:text-gray-400">
                      Folder
                    </p>
                  {/if}
                </div>
              </div>
            </button>
          {/each}
        </div>
      {/if}
    </div>
  </div>
</PageWrapper>
